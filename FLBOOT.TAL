;******************************* FLBOOT.TAL ********************************
;  (C) Copyright 1987-1993  Computer System Architects, Provo UT.           *
;  This  program is the property of Computer System Architects (CSA)        *
;  and is provided only as an example of a transputer/PC program for        *
;  use  with CSA's Transputer Education Kit and other transputer products.  *
;  You may freely distribute copies or modifiy the program as a whole or in *
;  part, provided you insert in each copy appropriate copyright notices and *
;  disclaimer of warranty and send to CSA a copy of any modifications which *
;  you plan to distribute.						    *
;  This program is provided as is without warranty of any kind. CSA is not  *
;  responsible for any damages arising out of the use of this program.      *
;***************************************************************************/
;****************************************************************************
; This program  boots a transputer, does necessary initialization and
; boots other transputers connected to it with an exact copy of itself. It
; keeps track of links through which other trnasputers are booted.
; After booting process, it loads the loader and sends copies of the loader
; to other transputers connected. Then it starts executing the loader.
;***************************************************************************

	.t800
;  val definition;

    .val    WORKSPACE_RESERVED, 5   ; 5 words is max additional workspace requirement for a concurrent process
	.val    RESERVE,16
	.val    CALLWSP,-4
	.val    INITIME,0
	.val    DELAY,10000
	.val    LOCTOP,16

    ;this struct shared with flboot & ident
	.val    MININT,1
	.val    MEMSTART,2
	.val    BOOTIN,3
	.val    BOOTOUT,4               ;4,5,6 contain links out (array of 3 link IDs, 0 if not connected to another transputer)
	.val    BOOTOUT1,4
	.val    BOOTOUT2,5
	.val    BOOTOUT3,6
	.val    LDSTART,7               ;zeroed during BOOTOUT save
	.val    ENTRYP,8
	.val    WSPACE,9
	.val    BO_IDX,9                ;NOTE shared location
	.val    LDADDR,10
	.val    UNUSED,11               ;was TRANTYPE - not used on wx9020
	.val    CODELEN,12              ;high order bytes must stay zeroed
	.val    BIDX,12                 ;NOTE shared location
	.val    LOOPA,13
	.val    LOOPB,14
	.val    TLINK,15                ;NOTE shared location
	.val    WSP,15

	.val    OSTATIC,1
	.val    OLINK,2
	.val    OBOOTOUT,3
	.val    OTEMP,4
	.val    OID,5
	.val    OLOCAL,6

	.val    OBUFWS,OLOCAL+WORKSPACE_RESERVED     
	
	.val    STATUS,0x80000F00
	.val    BOOTED,0xB007EEED

	.pub    START
;initialization

	.align
START:  
    ajw     RESERVE                 ;reserve work space (16 words) -> Wptr = memstart + codelen + 16w (8000 019c)
	stl     BOOTIN                  ;discard Iptr
	stl     BOOTIN                  ;discard Wdesc
	stl     BOOTIN                  ;Areg = bootin
    ldmemstartval
    stl     MEMSTART                ;save memory start (start of bootstrap code)
	ldc     @END-@START             
	stl     CODELEN                 ;save length of bootstrap code
	mint
	stl     MININT                  ;save MIN INTEGER (more efficient to 'ldl MININT' than mint)
	ldl     MININT                  ;init process front pointers
	stlf
	ldl     MININT
	sthf
I1: ldc     0                       ;init links and event
	stl     LOOPA                   ;LOOPA=0 (lend control block 0:11)
	ldc     11
	stl     LOOPB                   
I2: ldl     MININT                  ;init link control words to minint
	ldl     LOOPA                   
	ldl     MININT                  
	wsub                            
	stnl    0                       ;minint[LOOPA+0]=minint
	ldlp    LOOPA
	ldc     I3-I2
	lend                            ;inc & test loop control struct
I3: ldc     INITIME                 ;start timer at INITIME(0)
	sttimer
	testerr                         ;clear error flag
	clrhalterr                      ; halt on error

    ldc BOOTED ; STATUS = BOOTED
    ldc STATUS
    stnl 0

   ;ldl MININT
   ;adc 4
   ;ldl BOOTIN  ;good (0x80000014)
   ;ldl MEMSTART ;good (0x80000070)
   ;ldl CODELEN ;good
   ;ldlp 1
   ;outword 

   ;one flash for loader starting
   ;seterr                          ;error LED ON
   ;ldtimer
   ;adc    16000
   ;tin                             ;end delay
   ;testerr                         ;error LED OFF
   ;adc    16000
   ;tin                             ;end delay
  
	ldc     0                       ;BOOTOUT[0]:= 0 (default to inactive link)
	stl     BOOTOUT1
	ldc     0        
	stl     BOOTOUT2
	ldc     0        
	stl     BOOTOUT3
	ldc     0        
	stl     BO_IDX                  ;loop 0,1,2 through BOOTOUT array

   
; bootstrap neighbors
; send bootstrap out on all links, except link booted from. Use processes since in,out can block

	ldlp    LOCTOP                  ;init new work space ptr (at top of current locals)
	stl     WSP
	ldc     0                       ;loop i:= 0 for 4 each link
	stl     LOOPA                   ;LOOPA = lend control struct 0:4
	ldc     4
	stl     LOOPB
B1: ldl     LOOPA                   ;if LINKIN[i] <> BOOTIN
	ldl     MININT
	ldnlp   4
	wsub
	ldl     BOOTIN
	diff
	cj      @B3
	ldl     WSP                     ;alloc OUTBUF work space
	ldnlp   OBUFWS
	stl     WSP
	ldl     LOOPA                   ;save LINKOUT[i]
	ldl     MININT
	wsub
	ldl     WSP
	stnl    OLINK

	;{{{ PAR will store at OBOOTOUT the out link register address if bootstrap recieved
	ldl     BO_IDX
	ldlp    BOOTOUT
	wsub
	ldl     WSP
	stnl    OBOOTOUT       
	;}}}
	
	ldlp    0                       ;save static link
	ldl     WSP
	stnl    OSTATIC
	ldc     OUTBUF-B2               ;save iptr to OUTBUF
	ldpi
B2: ldl     WSP
	stnl    -1
	ldl     WSP                     ;load new work space ptr
	runp                            ;run output buffer process

	ldl     BO_IDX
	adc     1
	stl     BO_IDX

B3: ldlp    LOOPA
	ldc     B4-B1
	lend                            ;end loop
B4: 
    ldtimer                         ;wait for any com. to finish
	adc     DELAY
	tin                             ;block until timer reaches DELAY

    ;{{{flash err for bootin link number
	;ldc     0                       ;loop i:= 0 for 4 each link
	;stl     LOOPA                   ;LOOPA = lend control struct 0:4
    ;ldl     BOOTIN
    ;ldl     MININT
    ;diff
    ;ldc 16
    ;sub
    ;ldc 4
    ;div
	;stl     LOOPB                   ;LOOPB=(BOOTIN-MININT-0x10)/4 -> 0,1,2,3
	;ldl LOOPB
	;cj @F4
F1: ;seterr                          ;error LED ON
    ;ldtimer
    ;adc    14000
    ;tin                             ;end delay
    ;testerr                         ;error LED OFF
    ;ldtimer
    ;adc    14000
    ;tin                             ;end delay
F3: ;ldlp    LOOPA
	;ldc     F4-F1
	;lend                            ;end loop
F4: ;stopp
    ;}}}

;  loader and executer setup (received on same link as bootstrap)

    ;ldlp    CODELEN                 ;input length of fload loader
    ;ldl     BOOTIN
    ;ldc     1
    ;in                              ;A=len, B=link, C=addr
    ;ldl     MEMSTART                ;input fload loader
    ;ldl     BOOTIN
    ;ldl     CODELEN
    ;in

; send loader to neighbors
H2: ldc     0                       ;loop i:= 0 for 3 each BOOTOUT link
    stl     LOOPA
    ldc     3
    stl     LOOPB
H3: 
    ldl     LOOPA                   ;TLINK:= BOOTOUT[i]
    ldlp    BOOTOUT
    wsub
    ldnl    0
    stl     TLINK
    ldl     TLINK                   ;if TLINK <> 0
    cj      @H4

   ; SHOULD HAVE (with 2 cards) = 5*2 blinks, 1*1 blink & 6*0 blink (as expected from ispy)
   ; XXX now 3 on each processor XXX

   seterr                          ;error LED ON
   ldtimer
   adc    4000
   tin                             ;end delay
   testerr                         ;error LED OFF
   ldtimer
   adc    4000
   tin                             ;end delay

H4: ldlp    LOOPA
    ldc     H5-H3
    lend                            ;end loop
H5
    stopp
  

;       output buffer
OUTBUF: 
    ;peek STATUS word to see if proc already booted
    ldl     OLINK
    ldc     1                       ;PEEK,ADDR
    outbyte
    ldl     OLINK
    ldc     STATUS
    outword
    ldlp    OTEMP
    ldl     OLINK                   ;input reg is 16 bytes on from output
    adc     16
    ldc     4                       ;read a word
    in
    ldl     OTEMP
    ldc     BOOTED
    diff
    cj      @O1

    ;poke STATUS=BOOTED to mark proc as booted
    ldl     OLINK
    ldc     0                       ;POKE,ADDR,VAL
    outbyte
    ldl     OLINK
    ldc     STATUS
    outword
    ldl     OLINK
    ldc     BOOTED
    outword

    ;send bootstrap
    ldl     OLINK                   ;load output link
    ldl     OSTATIC                 ;load code length
    ldnl    CODELEN
    outbyte                         ;output code length
    ldl     OSTATIC                 ;load code start
    ldnl    MEMSTART
    ldl     OLINK                   ;load output link
    ldl     OSTATIC                 ;load code length
    ldnl    CODELEN
    out                             ;output code

    ;if the code got this far it means the worm will be recieved by a downstream transputer
    ;mark this boot link as active - store the output link register address into BOOTOUT array
    ldl     OLINK
    ldl     OBOOTOUT
    stnl    0

O1: 
    stopp

        .align
END:    .end
