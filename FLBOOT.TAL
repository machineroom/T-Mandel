;******************************* FLBOOT.TAL ********************************
;  (C) Copyright 1987-1993  Computer System Architects, Provo UT.           *
;  This  program is the property of Computer System Architects (CSA)        *
;  and is provided only as an example of a transputer/PC program for        *
;  use  with CSA's Transputer Education Kit and other transputer products.  *
;  You may freely distribute copies or modifiy the program as a whole or in *
;  part, provided you insert in each copy appropriate copyright notices and *
;  disclaimer of warranty and send to CSA a copy of any modifications which *
;  you plan to distribute.						    *
;  This program is provided as is without warranty of any kind. CSA is not  *
;  responsible for any damages arising out of the use of this program.      *
;***************************************************************************/
;****************************************************************************
; This program  boots a transputer, does necessary initialization and
; boots other transputers connected to it with an exact copy of itself. It
; keeps track of links through which other trnasputers are booted.
; After booting process, it loads the loader and sends copies of the loader
; to other transputers connected. Then it starts executing the loader.
;***************************************************************************

	.t800
;  val definition;

	.val    RESERVE,16
	.val    CALLWSP,-4
	.val    INITIME,0
	.val    DELAY,16*600      ;16*2- only first rack gets loader (nnodes=13). 16*6 - all get loader BUT nnodes is invalid, even for 13 processors.
	.val    T805,  0x0a
	.val    T800D, 0x60
	.val    T414B, 0x61
	.val    LOCTOP,16

    ;this struct shared with flboot & ident
	.val    MININT,1
	.val    MEMSTART,2
	.val    BOOTIN,3
	.val    BOOTOUT,4               ;4,5,6 contain links out (array of 3 link IDs, 0 if not connected to another transputer)
	.val    BOOTOUT1,4
	.val    BOOTOUT2,5
	.val    BOOTOUT3,6
	.val    LDSTART,7               ;zeroed during BOOTOUT save
	.val    ENTRYP,8
	.val    WSPACE,9
	.val    BO_IDX,9                ;NOTE shared location
	.val    LDADDR,10
	.val    UNUSED,11               ;was TRANTYPE - not used on wx9020
	.val    CODELEN,12              ;high order bytes must stay zeroed
	.val    BIDX,12                 ;NOTE shared location
	.val    LOOPA,13
	.val    LOOPB,14
	.val    TLINK,15                ;NOTE shared location
	.val    WSP,15

	.val    OBUFWS,7
	.val    OSTATIC,1
	.val    OLINK,2
	.val    OBOOTOUT,3
	.val    OLOCAL,4
	
	.val    STATUS,0x80000F00
	.val    BOOTED,0xB007EEED


	.pub    START
;initialization

	.align
START:  ajw     RESERVE                 ;reserve work space
	call    0                       ;save registers into workspace. Fills: MININT, MEMSTART & BOOTIN (from Creg)
	ldc     @START - @S1
	ldpi
S1: stl     MEMSTART                ;save memory start
	ldlp    4-RESERVE               ;calc code length
	ldl     MEMSTART
	diff
	stl     CODELEN
	mint
	stl     MININT                  ;save MIN INTEGER
	ldl     MININT                  ;init process front pointers
	stlf
	ldl     MININT
	sthf
I1: ldc     0                       ;init links and event
	stl     LOOPA                   ;LOOPA=0 (lend control block 0:11)
	ldc     11
	stl     LOOPB                   
I2: ldl     MININT                  ;init link control words to minint
	ldl     LOOPA                   
	ldl     MININT                  
	wsub                            
	stnl    0                       ;minint[LOOPA+0]=minint
	ldlp    LOOPA
	ldc     I3-I2
	lend                            ;inc & test loop control struct
I3: ldc     INITIME                 ;start timer at INITIME(0)
	sttimer

	;{{{ STATUS=BOOTED
	ldc     BOOTED
	ldc     STATUS
	stnl    0
	;}}}
	
	ldc     0                       ;BOOTOUT[0]:= 0 (default to inactive link)
	stl     BOOTOUT1
	ldc     0        
	stl     BOOTOUT2
	ldc     0        
	stl     BOOTOUT3
	ldc     0        
	stl     BO_IDX                  ;loop 0,1,2 through BOOTOUT array

; bootstrap neighbors
; send bootstrap out on all links, except link booted from. Use high-prio processes to do all 3 links in PAR
; fire & forget, i.e don't care if bootstrap accepted

	ldlp    LOCTOP-OLOCAL           ;init new work space ptr
	stl     WSP
	ldc     0                       ;loop i:= 0 for 4 each link
	stl     LOOPA                   ;LOOPA = lend control struct 0:4
	ldc     4
	stl     LOOPB
B1: ldl     LOOPA                   ;if LINKIN[i] <> BOOTIN
	ldl     MININT
	ldnlp   4
	wsub
	ldl     BOOTIN
	diff
	cj      @B3
	ldl     WSP                     ;alloc OUTBUF work space
	ldnlp   OBUFWS
	stl     WSP
	ldl     LOOPA                   ;save LINKOUT[i]
	ldl     MININT
	wsub
	ldl     WSP
	stnl    OLINK

	;{{{ PAR will store at OBOOTOUT the out link register address if bootstrap recieved
	ldl     BO_IDX
	ldlp    BOOTOUT
	wsub
	ldl     WSP
	stnl    OBOOTOUT       
	;}}}
	
	ldlp    0                       ;save static link
	ldl     WSP
	stnl    OSTATIC
	ldc     OUTBUF-B2               ;save iptr to OUTBUF
	ldpi
B2: ldl     WSP
	stnl    -1
	ldl     WSP                     ;load new work space ptr
	runp                            ;run output buffer at high pri
	ldl     BO_IDX
	adc     1
	stl     BO_IDX

B3: ldlp    LOOPA
	ldc     B4-B1
	lend                            ;end loop
B4: 
    ldtimer                         ;wait for any com. to finish
	adc     DELAY
	tin                             ;block until timer reaches DELAY

;  loader and executer setup (received on same link as bootstrap)

    ldlp    CODELEN                 ;input length of fload loader
    ldl     BOOTIN
    ldc     1
    in                              ;A=len, B=link, C=addr
    ldl     MEMSTART                ;input fload loader
    ldl     BOOTIN
    ldl     CODELEN
    in
    ;ONLY ONE FLASH HERE = i.e. bootstrap is only run once

; send loader to neighbors
H2: ldc     0                       ;loop i:= 0 for 3 each BOOTOUT link
    stl     LOOPA
    ldc     3
    stl     LOOPB
H3: 
    ldl     LOOPA                   ;TLINK:= BOOTOUT[i]
    ldlp    BOOTOUT
    wsub
    ldnl    0
    stl     TLINK
    ldl     TLINK                   ;if TLINK <> 0
    cj      @H4

    ;peek STATUS word to see if proc already booted
    ;{{{
    ;ldl     TLINK
    ;ldc     1
    ;outbyte
    ;ldl     TLINK
    ;ldc     STATUS
    ;outword
    ;ldlp    LDSTART ;temp abuse another var
    ;ldl     TLINK   ;input reg is 16 bytes on from output
    ;adc     16
    ;ldc     4       ;read a word
    ;in
    ;ldl     LDSTART
    ;ldc     BOOTED
    ;diff
    ;cj @H4
    ;}}}
    ;poke STATUS=BOOTED to mark proc as booted
    ;{{{
    ;ldl     TLINK
    ;ldc     0
    ;outbyte
    ;ldl     TLINK
    ;ldc     STATUS
    ;outword
    ;ldl     TLINK
    ;ldc     BOOTED
    ;outword
    ;}}}
   ; SHOULD HAVE 2 cards = 5*2 blinks, 1*1 blink & 6*0 blink (as expected from ispy)
   ; XXX now 3 on each processor XXX
   ;seterr                          ;error LED ON
   ;ldtimer
   ;adc    4000
   ;tin                             ;end delay
    ldlp    CODELEN                 ;send out length to neighbors (1 byte)
    ldl     TLINK
    ldc     1
    out
    ldl     MEMSTART                ;send out code to neighbors
    ldl     TLINK
    ldl     CODELEN
    out    
   ;testerr                         ;error LED OFF
   ;ldtimer
   ;adc     4000
   ;tin                             ;end delay
   ;j @H5    ; TESTING only boot fist non-zero linkid (only 1 flash)
H4: ldlp    LOOPA
    ldc     H5-H3
    lend                            ;end loop
H5
    ;start loader on self
    ldlp    LOCTOP                  ;init load start address
    stl     LDSTART
    ldl     LDSTART                 ;init entry point
    stl     ENTRYP
    ldlp    CALLWSP                 ;init work space
    stl     WSPACE
    ldl     MEMSTART                ;go to loader
    gcall

;       output buffer
OUTBUF: 
        ldl     OLINK                   ;load output link
        ldl     OSTATIC                 ;load code length
        ldnl    CODELEN
        outbyte                         ;output code length
        ldl     OSTATIC                 ;load code start
        ldnl    MEMSTART
        ldl     OLINK                   ;load output link
        ldl     OSTATIC                 ;load code length
        ldnl    CODELEN
        out                             ;output code
        
        ;if the code got this far it means the worm was recieved by a downstream transputer
        ;mark this boot link as active - store the output link register address into BOOTOUT array
        ldl     OLINK
        ldl     OBOOTOUT
        stnl    0
OB1:    stopp

        .align
END:    .end
